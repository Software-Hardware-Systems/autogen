// Copyright (c) Microsoft Corporation. All rights reserved.
// Hubber.cs

using System.Text.Json;
using DevTeam.Backend.Agents.DeveloperLead;
using DevTeam.Backend.Agents.ProductManager;
using DevTeam.Backend.Services;
using Microsoft.AutoGen.Contracts;
using Microsoft.AutoGen.Core;

namespace DevTeam.Backend.Agents;

/// <summary>
/// Handles GitHub-related workflows by creating issues, branches, and comments based on various
/// events generated by the GitHubWebHookProcessor in response to GitHubApp events.
/// </summary>
/// <param name="ghService">Used for managing GitHub operations like creating issues and branches.</param>
/// <param name="id">Identifies the agent within the system.</param>
/// <param name="runtime">Provides the execution context for the agent's operations.</param>
/// <param name="logger">Facilitates logging for tracking the agent's activities and errors.</param>
[TypeSubscription(SkillType.Hubber)]
public class Hubber(
    IManageGithub ghService,
    AgentId id,
    IAgentRuntime runtime,
    ILogger<Hubber>? logger = null)
    :
    BaseAgent(id, runtime, nameof(Hubber), logger),
    IHandle<NewAsk>,
    IHandle<ReadmeGenerated>,
    IHandle<DevPlanGenerated>,
    IHandle<DevPlanCreated>,
    IHandle<ReadmeStored>,
    IHandle<CodeGenerated>
{
    /// <summary>
    /// When the user creates a new Issue (NewAsk), create two new issues:
    /// One for the PM to create a README.md file
    /// Another for the DevLead to create a plan
    /// Then create a new branch for the dev-team to work on
    /// Then post comments to the PM and DevLead issues with the links to the new issues
    /// The comments contain magic strings PM.Readme and DevLead.Plan to
    /// indicate which dev-team agent should handle the issue
    /// </summary>
    /// <param name="newAsk"></param>
    /// <param name="messageContext"></param>
    /// <returns></returns>
    public async ValueTask HandleAsync(NewAsk newAsk, MessageContext messageContext)
    {
        var (org, repo, issueNumber, _) = ExtractDetailsFromTopicSource(messageContext.Topic);

        await ghService.CreateBranch(org, repo, $"sk-{issueNumber}");

        // Note that the newAsk user message is incorporated into both the PM and DevLead issues

        var pmIssue = await ghService.CreateIssue(org, repo, newAsk.UserMessage, $"{SkillType.ProductOwner}.{nameof(PMSkills.Readme)}", issueNumber);
        await ghService.PostComment(org, repo, issueNumber, $" - #{pmIssue} - tracks {SkillType.ProductOwner}.{nameof(PMSkills.Readme)}");

        var devLeadIssue = await ghService.CreateIssue(org, repo, newAsk.UserMessage, $"{SkillType.DeveloperLead}.{nameof(DeveloperLeadSkills.Plan)}", issueNumber);
        await ghService.PostComment(org, repo, issueNumber, $" - #{devLeadIssue} - tracks {SkillType.DeveloperLead}.{nameof(DeveloperLeadSkills.Plan)}");
    }

    /// <summary>
    /// When a README.md file is generated, post it as a comment to the associated issue.
    /// </summary>
    /// <param name="readmeGenerated"></param>
    /// <param name="messageContext"></param>
    /// <returns></returns>
    public async ValueTask HandleAsync(ReadmeGenerated readmeGenerated, MessageContext messageContext)
    {
        var (org, repo, issueNumber, _) = ExtractDetailsFromTopicSource(messageContext.Topic);

        var contents = string.IsNullOrEmpty(readmeGenerated.Readme) ? "Sorry, I got tired, can you try again please? " : readmeGenerated.Readme;
        await ghService.PostComment(org, repo, issueNumber, contents);
    }

    /// <summary>
    /// When a DevPlan is "Generated", post it as a comment to the associated issue
    /// The user then has an opportunity to comment and provide additional guidance related to the original ask.
    /// </summary>
    /// <param name="devPlanGenerated"></param>
    /// <param name="messageContext"></param>
    /// <returns></returns>
    public async ValueTask HandleAsync(DevPlanGenerated devPlanGenerated, MessageContext messageContext)
    {
        var (org, repo, issueNumber, _) = ExtractDetailsFromTopicSource(messageContext.Topic);

        var contents = string.IsNullOrEmpty(devPlanGenerated.DevPlan) ? "Sorry, I got tired, can you try again please? " : devPlanGenerated.DevPlan;
        await ghService.PostComment(org, repo, issueNumber, contents);
    }

    /// <summary>
    /// When code is Generated, post a comment to the associated issue with the contents of the code
    /// </summary>
    /// <param name="codeGenerated"></param>
    /// <param name="messageContext"></param>
    /// <returns></returns>
    public async ValueTask HandleAsync(CodeGenerated codeGenerated, MessageContext messageContext)
    {
        var (org, repo, issueNumber, _) = ExtractDetailsFromTopicSource(messageContext.Topic);

        var contents = string.IsNullOrEmpty(codeGenerated.Code) ? "Sorry, I got tired, can you try again please? " : codeGenerated.Code;
        await ghService.PostComment(org, repo, issueNumber, contents);
    }

    /// <summary>
    /// When a DevPlan is "Created"
    /// </summary>
    /// <param name="devPlanCreated"></param>
    /// <param name="messageContext"></param>
    /// <returns></returns>
    public async ValueTask HandleAsync(DevPlanCreated devPlanCreated, MessageContext messageContext)
    {
        var (org, repo, issueNumber, parentIssueNumber) = ExtractDetailsFromTopicSource(messageContext.Topic);

        var plan = JsonSerializer.Deserialize<DevPlan>(devPlanCreated.DevPlan);
        var prompts = plan!.Steps.SelectMany(s => s.Subtasks!.Select(st => st.Prompt));

        foreach (var prompt in prompts)
        {
            var functionName = "Developer.Implement";
            var issue = await ghService.CreateIssue(org, repo, prompt!, functionName, issueNumber);
            var commentBody = $" - #{issue} - tracks {functionName}";
            await ghService.PostComment(org, repo, issueNumber, commentBody);
        }
    }

    public async ValueTask HandleAsync(ReadmeStored readmeStored, MessageContext messageContext)
    {
        var (org, repo, issueNumber, parentIssueNumber) = ExtractDetailsFromTopicSource(messageContext.Topic);
        var branch = $"sk-{issueNumber}";
        await ghService.CommitToBranch(org, repo, parentIssueNumber, issueNumber, "output", branch);
        await ghService.CreatePR(org, repo, issueNumber, branch);
    }

    private (string Org, string Repo, long IssueNumber, long ParentIssueNumber) ExtractDetailsFromTopicSource(TopicId? topicId)
    {
        if (string.IsNullOrEmpty(topicId?.Source))
        {
            throw new ArgumentNullException(nameof(topicId), "TopicId cannot be null");
        }

        var parts = topicId.Value.Source.Split('-');
        if (parts.Length >= 4)
        {
            return (
                Org: parts[0],
                Repo: parts[1],
                IssueNumber: TryParseLong(parts[2]),
                ParentIssueNumber: TryParseLong(parts[3])
            );
        }
        return (
            Org: parts[0],
            Repo: parts[1],
            IssueNumber: TryParseLong(parts[2]),
            ParentIssueNumber: 0
        );
    }

    private long TryParseLong(object? value)
    {
        return long.TryParse(value?.ToString(), out var result) ? result : 0;
    }
}
